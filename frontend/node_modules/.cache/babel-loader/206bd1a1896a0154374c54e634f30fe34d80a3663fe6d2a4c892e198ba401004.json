{"ast":null,"code":"var _jsxFileName = \"/Users/komasz/Documents/GitHub/ai-voice/frontend/src/components/AudioChat/AudioChat.tsx\",\n  _s = $RefreshSig$();\nimport React, { useCallback, useEffect, useMemo, useState, useRef } from 'react';\nimport { socket } from '../../services/socket';\nimport { makeAutoObservable } from 'mobx';\nimport { observer } from 'mobx-react-lite';\nimport { AudioChatIconButton, AudioChatRuningIcon, StopAudioIconButton, ChatRuningWrapper } from './AudioChat.styled';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nclass AudioQueueManager {\n  constructor() {\n    this.audioQueue = [];\n    this.isPlaying = false;\n    this.pitchFactor = 0.5;\n    makeAutoObservable(this);\n  }\n  setPitchFactor(factor) {\n    this.pitchFactor = factor;\n  }\n  addAudioToQueue(audioData) {\n    this.audioQueue.push(audioData);\n    this.playNext();\n  }\n  async playNext() {\n    if (this.isPlaying || this.audioQueue.length === 0) return;\n    this.isPlaying = true;\n    const audioData = this.audioQueue.shift();\n    await this.playAudio(audioData);\n    this.isPlaying = false;\n    this.playNext();\n  }\n  playAudio(audioBuffer) {\n    return new Promise(resolve => {\n      const audioContext = new (window.AudioContext || window.webkitAudioContext)();\n      const binaryString = atob(audioBuffer);\n      const len = binaryString.length;\n      const int16Array = new Int16Array(len / 2);\n      for (let i = 0; i < len; i += 2) {\n        int16Array[i / 2] = binaryString.charCodeAt(i) | binaryString.charCodeAt(i + 1) << 8;\n      }\n      const float32Array = new Float32Array(int16Array.length);\n      for (let i = 0; i < int16Array.length; i++) {\n        float32Array[i] = int16Array[i] / 0x7fff;\n      }\n      const audioBufferObj = audioContext.createBuffer(1, float32Array.length, audioContext.sampleRate);\n      audioBufferObj.copyToChannel(float32Array, 0);\n      const source = audioContext.createBufferSource();\n      source.buffer = audioBufferObj;\n      source.playbackRate.value = this.pitchFactor;\n      source.connect(audioContext.destination);\n      source.onended = () => resolve();\n      source.start(0);\n    });\n  }\n  stopAudio() {\n    this.isPlaying = false;\n    this.audioQueue = [];\n  }\n}\nlet audioContext = null;\nlet mediaStream = null;\nconst AudioChat = ({\n  voiceEnabled,\n  onVoiceStart,\n  onVoiceStop\n}) => {\n  _s();\n  const audioQueueManager = useMemo(() => new AudioQueueManager(), []);\n  const [currentResponseId, setCurrentResponseId] = useState(null);\n  const [responseDuration, setResponseDuration] = useState(0);\n  const responseTimerRef = useRef(null);\n  const MAX_RESPONSE_DURATION = 12000; // 12 seconds max continuous response time\n  const [lastTranscriptUpdate, setLastTranscriptUpdate] = useState(Date.now());\n  const [transcriptContent, setTranscriptContent] = useState('');\n  const [isRepetitiveResponse, setIsRepetitiveResponse] = useState(false);\n  const previousTranscriptRef = useRef([]);\n  const handleStartVoiceChat = useCallback(async () => {\n    onVoiceStart();\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: 24000,\n          channelCount: 1,\n          echoCancellation: true\n        }\n      });\n      mediaStream = stream;\n      audioContext = new AudioContext({\n        sampleRate: 24000\n      });\n      const source = audioContext.createMediaStreamSource(stream);\n      const processor = audioContext.createScriptProcessor(4096, 1, 1);\n      source.connect(processor);\n      processor.connect(audioContext.destination);\n      processor.onaudioprocess = event => {\n        const inputBuffer = event.inputBuffer;\n        const inputData = inputBuffer.getChannelData(0);\n        const int16Array = new Int16Array(inputData.length);\n        for (let i = 0; i < inputData.length; i++) {\n          int16Array[i] = Math.min(1, Math.max(-1, inputData[i])) * 0x7fff;\n        }\n        const base64String = btoa(String.fromCharCode(...new Uint8Array(int16Array.buffer)));\n        socket.emit('audioInput', base64String);\n      };\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n    }\n  }, [onVoiceStart]);\n  const handleStopVoiceChat = useCallback(() => {\n    onVoiceStop();\n    if (audioContext) {\n      audioContext.close();\n      audioContext = null;\n    }\n    if (mediaStream) {\n      mediaStream.getTracks().forEach(track => track.stop());\n      mediaStream = null;\n    }\n  }, [onVoiceStop]);\n  useEffect(() => {\n    function handleAudioResponse(data) {\n      if (data.delta) {\n        audioQueueManager.addAudioToQueue(data.delta);\n      }\n    }\n    if (voiceEnabled) {\n      socket.on('audioResponse', handleAudioResponse);\n    }\n    return () => {\n      socket.off('audioResponse', handleAudioResponse);\n    };\n  }, [voiceEnabled, audioQueueManager]);\n  useEffect(() => {\n    function handleSpeechStarted() {\n      audioQueueManager.stopAudio();\n    }\n    socket.on('speechStarted', handleSpeechStarted);\n    return () => {\n      socket.off('speechStarted', handleSpeechStarted);\n    };\n  }, [audioQueueManager]);\n  useEffect(() => {\n    function handleTextTranscript(data) {\n      if (data.part && data.part.transcript) {\n        const currentTime = Date.now();\n        setLastTranscriptUpdate(currentTime);\n        const newTranscript = data.part.transcript;\n        setTranscriptContent(newTranscript);\n        const segments = newTranscript.split('. ');\n        if (segments.length > 3) {\n          const lastThreeSegments = segments.slice(-3);\n          const similarityCount = lastThreeSegments.filter(segment => lastThreeSegments.some(other => other !== segment && (other.includes(segment) || segment.includes(other)))).length;\n          if (similarityCount >= 2) {\n            console.log('Detected repetitive response pattern');\n            setIsRepetitiveResponse(true);\n            if (currentResponseId) {\n              socket.emit('stop', currentResponseId);\n              audioQueueManager.stopAudio();\n              if (responseTimerRef.current) {\n                clearInterval(responseTimerRef.current);\n              }\n            }\n          }\n        }\n        previousTranscriptRef.current = [...previousTranscriptRef.current, newTranscript].slice(-5);\n      }\n    }\n    socket.on('textTranscript', handleTextTranscript);\n    return () => {\n      socket.off('textTranscript', handleTextTranscript);\n    };\n  }, [audioQueueManager, currentResponseId]);\n  useEffect(() => {\n    const transcriptCheckInterval = setInterval(() => {\n      if (currentResponseId && Date.now() - lastTranscriptUpdate > 3000) {\n        console.log('No transcript update for 3 seconds, potential stuck response');\n        if (transcriptContent && (transcriptContent.endsWith('.') || transcriptContent.endsWith('?') || transcriptContent.endsWith('!'))) {\n          console.log('Response appears to be at a natural stopping point, cancelling');\n          socket.emit('stop', currentResponseId);\n          audioQueueManager.stopAudio();\n        }\n      }\n    }, 1000);\n    return () => {\n      clearInterval(transcriptCheckInterval);\n    };\n  }, [currentResponseId, lastTranscriptUpdate, transcriptContent, audioQueueManager]);\n  useEffect(() => {\n    function handleResponseCreated(data) {\n      if (data.response_id) {\n        setCurrentResponseId(data.response_id);\n        setResponseDuration(0);\n        setIsRepetitiveResponse(false);\n        setLastTranscriptUpdate(Date.now());\n        setTranscriptContent('');\n        if (responseTimerRef.current) {\n          clearInterval(responseTimerRef.current);\n        }\n        responseTimerRef.current = setInterval(() => {\n          setResponseDuration(prev => {\n            const newDuration = prev + 100;\n            if ((newDuration >= MAX_RESPONSE_DURATION || isRepetitiveResponse) && currentResponseId) {\n              console.log(`Stopping response ${currentResponseId} - ${isRepetitiveResponse ? 'repetitive response' : 'max duration exceeded'}`);\n              socket.emit('stop', currentResponseId);\n              audioQueueManager.stopAudio();\n              if (responseTimerRef.current) {\n                clearInterval(responseTimerRef.current);\n              }\n            }\n            return newDuration;\n          });\n        }, 100);\n      }\n    }\n    function handleResponseDone() {\n      if (responseTimerRef.current) {\n        clearInterval(responseTimerRef.current);\n      }\n      setCurrentResponseId(null);\n      setResponseDuration(0);\n      setIsRepetitiveResponse(false);\n    }\n    socket.on('response.created', handleResponseCreated);\n    socket.on('response.done', handleResponseDone);\n    return () => {\n      socket.off('response.created', handleResponseCreated);\n      socket.off('response.done', handleResponseDone);\n      if (responseTimerRef.current) {\n        clearInterval(responseTimerRef.current);\n      }\n    };\n  }, [currentResponseId, isRepetitiveResponse, audioQueueManager]);\n  if (!voiceEnabled) {\n    return /*#__PURE__*/_jsxDEV(AudioChatIconButton, {\n      onClick: handleStartVoiceChat,\n      src: \"/audio-chat-icon.svg\",\n      alt: \"Audio Chat\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 307,\n      columnNumber: 7\n    }, this);\n  } else {\n    return /*#__PURE__*/_jsxDEV(ChatRuningWrapper, {\n      children: [/*#__PURE__*/_jsxDEV(StopAudioIconButton, {\n        onClick: handleStopVoiceChat,\n        src: \"/arrow-back-icon.svg\",\n        alt: \"Stop Audio Chat\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 316,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(AudioChatRuningIcon, {\n        onClick: handleStopVoiceChat,\n        src: \"/audio-chat-icon-run.svg\",\n        alt: \"Chat runing\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 321,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 315,\n      columnNumber: 7\n    }, this);\n  }\n};\n_s(AudioChat, \"K0RqRtsYCKoGqGLNTa808cPVcEs=\");\n_c = AudioChat;\nexport default _c2 = observer(AudioChat);\nvar _c, _c2;\n$RefreshReg$(_c, \"AudioChat\");\n$RefreshReg$(_c2, \"%default%\");","map":{"version":3,"names":["React","useCallback","useEffect","useMemo","useState","useRef","socket","makeAutoObservable","observer","AudioChatIconButton","AudioChatRuningIcon","StopAudioIconButton","ChatRuningWrapper","jsxDEV","_jsxDEV","AudioQueueManager","constructor","audioQueue","isPlaying","pitchFactor","setPitchFactor","factor","addAudioToQueue","audioData","push","playNext","length","shift","playAudio","audioBuffer","Promise","resolve","audioContext","window","AudioContext","webkitAudioContext","binaryString","atob","len","int16Array","Int16Array","i","charCodeAt","float32Array","Float32Array","audioBufferObj","createBuffer","sampleRate","copyToChannel","source","createBufferSource","buffer","playbackRate","value","connect","destination","onended","start","stopAudio","mediaStream","AudioChat","voiceEnabled","onVoiceStart","onVoiceStop","_s","audioQueueManager","currentResponseId","setCurrentResponseId","responseDuration","setResponseDuration","responseTimerRef","MAX_RESPONSE_DURATION","lastTranscriptUpdate","setLastTranscriptUpdate","Date","now","transcriptContent","setTranscriptContent","isRepetitiveResponse","setIsRepetitiveResponse","previousTranscriptRef","handleStartVoiceChat","stream","navigator","mediaDevices","getUserMedia","audio","channelCount","echoCancellation","createMediaStreamSource","processor","createScriptProcessor","onaudioprocess","event","inputBuffer","inputData","getChannelData","Math","min","max","base64String","btoa","String","fromCharCode","Uint8Array","emit","error","console","handleStopVoiceChat","close","getTracks","forEach","track","stop","handleAudioResponse","data","delta","on","off","handleSpeechStarted","handleTextTranscript","part","transcript","currentTime","newTranscript","segments","split","lastThreeSegments","slice","similarityCount","filter","segment","some","other","includes","log","current","clearInterval","transcriptCheckInterval","setInterval","endsWith","handleResponseCreated","response_id","prev","newDuration","handleResponseDone","onClick","src","alt","fileName","_jsxFileName","lineNumber","columnNumber","children","_c","_c2","$RefreshReg$"],"sources":["/Users/komasz/Documents/GitHub/ai-voice/frontend/src/components/AudioChat/AudioChat.tsx"],"sourcesContent":["import React, { useCallback, useEffect, useMemo, useState, useRef } from 'react';\nimport { socket } from '../../services/socket';\nimport { makeAutoObservable } from 'mobx';\nimport { observer } from 'mobx-react-lite';\nimport {\n  AudioChatIconButton,\n  AudioChatRuningIcon,\n  StopAudioIconButton,\n  ChatRuningWrapper,\n} from './AudioChat.styled';\n\nclass AudioQueueManager {\n  audioQueue: string[] = [];\n  isPlaying = false;\n  pitchFactor = 0.5;\n\n  constructor() {\n    makeAutoObservable(this);\n  }\n\n  setPitchFactor(factor: number) {\n    this.pitchFactor = factor;\n  }\n\n  addAudioToQueue(audioData: string) {\n    this.audioQueue.push(audioData);\n    this.playNext();\n  }\n\n  async playNext() {\n    if (this.isPlaying || this.audioQueue.length === 0) return;\n\n    this.isPlaying = true;\n    const audioData = this.audioQueue.shift() as string;\n    await this.playAudio(audioData);\n\n    this.isPlaying = false;\n    this.playNext();\n  }\n\n  playAudio(audioBuffer: string): Promise<void> {\n    return new Promise(resolve => {\n      const audioContext = new (window.AudioContext ||\n        (window as any).webkitAudioContext)();\n\n      const binaryString = atob(audioBuffer);\n      const len = binaryString.length;\n      const int16Array = new Int16Array(len / 2);\n\n      for (let i = 0; i < len; i += 2) {\n        int16Array[i / 2] =\n          binaryString.charCodeAt(i) | (binaryString.charCodeAt(i + 1) << 8);\n      }\n\n      const float32Array = new Float32Array(int16Array.length);\n      for (let i = 0; i < int16Array.length; i++) {\n        float32Array[i] = int16Array[i] / 0x7fff;\n      }\n\n      const audioBufferObj = audioContext.createBuffer(\n        1,\n        float32Array.length,\n        audioContext.sampleRate,\n      );\n      audioBufferObj.copyToChannel(float32Array, 0);\n\n      const source = audioContext.createBufferSource();\n      source.buffer = audioBufferObj;\n      source.playbackRate.value = this.pitchFactor;\n\n      source.connect(audioContext.destination);\n      source.onended = () => resolve();\n      source.start(0);\n    });\n  }\n\n  stopAudio() {\n    this.isPlaying = false;\n    this.audioQueue = [];\n  }\n}\n\ninterface AudioChatProps {\n  voiceEnabled: boolean;\n  onVoiceStart: () => void;\n  onVoiceStop: () => void;\n}\n\nlet audioContext: AudioContext | null = null;\nlet mediaStream: MediaStream | null = null;\n\nconst AudioChat: React.FC<AudioChatProps> = ({\n  voiceEnabled,\n  onVoiceStart,\n  onVoiceStop,\n}) => {\n  const audioQueueManager = useMemo(() => new AudioQueueManager(), []);\n  const [currentResponseId, setCurrentResponseId] = useState<string | null>(null);\n  const [responseDuration, setResponseDuration] = useState<number>(0);\n  const responseTimerRef = useRef<NodeJS.Timeout | null>(null);\n  const MAX_RESPONSE_DURATION = 12000; // 12 seconds max continuous response time\n  const [lastTranscriptUpdate, setLastTranscriptUpdate] = useState<number>(Date.now());\n  const [transcriptContent, setTranscriptContent] = useState<string>('');\n  const [isRepetitiveResponse, setIsRepetitiveResponse] = useState<boolean>(false);\n  const previousTranscriptRef = useRef<string[]>([]);\n\n  const handleStartVoiceChat = useCallback(async () => {\n    onVoiceStart();\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: 24000,\n          channelCount: 1,\n          echoCancellation: true,\n        },\n      });\n      mediaStream = stream;\n\n      audioContext = new AudioContext({ sampleRate: 24000 });\n      const source = audioContext.createMediaStreamSource(stream);\n      const processor = audioContext.createScriptProcessor(4096, 1, 1);\n\n      source.connect(processor);\n      processor.connect(audioContext.destination);\n\n      processor.onaudioprocess = event => {\n        const inputBuffer = event.inputBuffer;\n        const inputData = inputBuffer.getChannelData(0);\n\n        const int16Array = new Int16Array(inputData.length);\n        for (let i = 0; i < inputData.length; i++) {\n          int16Array[i] = Math.min(1, Math.max(-1, inputData[i])) * 0x7fff;\n        }\n\n        const base64String = btoa(\n          String.fromCharCode(...new Uint8Array(int16Array.buffer)),\n        );\n        socket.emit('audioInput', base64String);\n      };\n    } catch (error) {\n      console.error('Error accessing microphone:', error);\n    }\n  }, [onVoiceStart]);\n\n  const handleStopVoiceChat = useCallback(() => {\n    onVoiceStop();\n    if (audioContext) {\n      audioContext.close();\n      audioContext = null;\n    }\n    if (mediaStream) {\n      mediaStream.getTracks().forEach(track => track.stop());\n      mediaStream = null;\n    }\n  }, [onVoiceStop]);\n\n  useEffect(() => {\n    function handleAudioResponse(data: any) {\n      if (data.delta) {\n        audioQueueManager.addAudioToQueue(data.delta);\n      }\n    }\n    if (voiceEnabled) {\n      socket.on('audioResponse', handleAudioResponse);\n    }\n    return () => {\n      socket.off('audioResponse', handleAudioResponse);\n    };\n  }, [voiceEnabled, audioQueueManager]);\n\n  useEffect(() => {\n    function handleSpeechStarted() {\n      audioQueueManager.stopAudio();\n    }\n    socket.on('speechStarted', handleSpeechStarted);\n    return () => {\n      socket.off('speechStarted', handleSpeechStarted);\n    };\n  }, [audioQueueManager]);\n\n  useEffect(() => {\n    function handleTextTranscript(data: any) {\n      if (data.part && data.part.transcript) {\n        const currentTime = Date.now();\n        setLastTranscriptUpdate(currentTime);\n\n        const newTranscript = data.part.transcript;\n        setTranscriptContent(newTranscript);\n\n        const segments = newTranscript.split('. ');\n        if (segments.length > 3) {\n          const lastThreeSegments = segments.slice(-3);\n\n          const similarityCount = lastThreeSegments.filter((segment: string) =>\n            lastThreeSegments.some((other: string) =>\n              other !== segment &&\n              (other.includes(segment) || segment.includes(other)),\n            ),\n          ).length;\n\n          if (similarityCount >= 2) {\n            console.log('Detected repetitive response pattern');\n            setIsRepetitiveResponse(true);\n\n            if (currentResponseId) {\n              socket.emit('stop', currentResponseId);\n              audioQueueManager.stopAudio();\n              if (responseTimerRef.current) {\n                clearInterval(responseTimerRef.current);\n              }\n            }\n          }\n        }\n\n        previousTranscriptRef.current = [...previousTranscriptRef.current, newTranscript].slice(-5);\n      }\n    }\n\n    socket.on('textTranscript', handleTextTranscript);\n\n    return () => {\n      socket.off('textTranscript', handleTextTranscript);\n    };\n  }, [audioQueueManager, currentResponseId]);\n\n  useEffect(() => {\n    const transcriptCheckInterval = setInterval(() => {\n      if (currentResponseId && Date.now() - lastTranscriptUpdate > 3000) {\n        console.log('No transcript update for 3 seconds, potential stuck response');\n\n        if (\n          transcriptContent &&\n          (transcriptContent.endsWith('.') ||\n            transcriptContent.endsWith('?') ||\n            transcriptContent.endsWith('!'))\n        ) {\n          console.log('Response appears to be at a natural stopping point, cancelling');\n          socket.emit('stop', currentResponseId);\n          audioQueueManager.stopAudio();\n        }\n      }\n    }, 1000);\n\n    return () => {\n      clearInterval(transcriptCheckInterval);\n    };\n  }, [currentResponseId, lastTranscriptUpdate, transcriptContent, audioQueueManager]);\n\n  useEffect(() => {\n    function handleResponseCreated(data: any) {\n      if (data.response_id) {\n        setCurrentResponseId(data.response_id);\n        setResponseDuration(0);\n        setIsRepetitiveResponse(false);\n\n        setLastTranscriptUpdate(Date.now());\n        setTranscriptContent('');\n\n        if (responseTimerRef.current) {\n          clearInterval(responseTimerRef.current);\n        }\n\n        responseTimerRef.current = setInterval(() => {\n          setResponseDuration(prev => {\n            const newDuration = prev + 100;\n            if ((newDuration >= MAX_RESPONSE_DURATION || isRepetitiveResponse) && currentResponseId) {\n              console.log(\n                `Stopping response ${currentResponseId} - ${\n                  isRepetitiveResponse ? 'repetitive response' : 'max duration exceeded'\n                }`,\n              );\n              socket.emit('stop', currentResponseId);\n              audioQueueManager.stopAudio();\n              if (responseTimerRef.current) {\n                clearInterval(responseTimerRef.current);\n              }\n            }\n            return newDuration;\n          });\n        }, 100);\n      }\n    }\n\n    function handleResponseDone() {\n      if (responseTimerRef.current) {\n        clearInterval(responseTimerRef.current);\n      }\n      setCurrentResponseId(null);\n      setResponseDuration(0);\n      setIsRepetitiveResponse(false);\n    }\n\n    socket.on('response.created', handleResponseCreated);\n    socket.on('response.done', handleResponseDone);\n\n    return () => {\n      socket.off('response.created', handleResponseCreated);\n      socket.off('response.done', handleResponseDone);\n      if (responseTimerRef.current) {\n        clearInterval(responseTimerRef.current);\n      }\n    };\n  }, [currentResponseId, isRepetitiveResponse, audioQueueManager]);\n\n  if (!voiceEnabled) {\n    return (\n      <AudioChatIconButton\n        onClick={handleStartVoiceChat}\n        src=\"/audio-chat-icon.svg\"\n        alt=\"Audio Chat\"\n      />\n    );\n  } else {\n    return (\n      <ChatRuningWrapper>\n        <StopAudioIconButton\n          onClick={handleStopVoiceChat}\n          src=\"/arrow-back-icon.svg\"\n          alt=\"Stop Audio Chat\"\n        />\n        <AudioChatRuningIcon\n          onClick={handleStopVoiceChat}\n          src=\"/audio-chat-icon-run.svg\"\n          alt=\"Chat runing\"\n        />\n      </ChatRuningWrapper>\n    );\n  }\n};\n\nexport default observer(AudioChat);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}